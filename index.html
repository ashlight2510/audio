<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Simple Audio Editor</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/wavesurfer.js@7"></script>
  <script src="https://unpkg.com/wavesurfer.js@7/dist/plugins/regions.min.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&family=Manrope:wght@400;600&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: radial-gradient(120% 120% at 20% 20%, #0ea5e9 0%, #0b1224 50%, #050915 85%);
    }
    body {
      font-family: "Manrope", system-ui, -apple-system, sans-serif;
      background: var(--bg);
      color: #f8fafc;
      min-height: 100vh;
    }
    .card {
      backdrop-filter: blur(10px);
      background: rgba(7, 12, 26, 0.65);
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.35);
    }
    .glass {
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.05);
    }
    .pill {
      background: linear-gradient(120deg, #22d3ee, #6366f1);
      color: #0b1224;
    }
  </style>
</head>
<body class="pb-16">
  <div class="max-w-6xl mx-auto px-5 lg:px-8 pt-10">
    <header class="flex flex-col gap-4 lg:gap-6">
      <div class="inline-flex items-center gap-2 text-xs uppercase tracking-[0.2em] pill px-3 py-1 rounded-full w-fit shadow-lg shadow-cyan-900/50">
        Browser-only · No install
      </div>
      <div class="flex flex-col lg:flex-row lg:items-end lg:justify-between gap-3">
        <div>
          <h1 class="text-4xl lg:text-5xl font-semibold" style="font-family:'Space Grotesk',sans-serif">Simple Audio Editor</h1>
          <p class="text-slate-200 mt-2 text-lg">Trim, merge and export — 100% client-side.</p>
        </div>
        <div class="text-sm text-slate-300 glass px-3 py-2 rounded-lg">
          <div>All processing happens in your browser.</div>
          <div class="text-slate-400">Large files may take time.</div>
        </div>
      </div>
    </header>

    <main class="mt-8 grid lg:grid-cols-5 gap-6">
      <section class="lg:col-span-3 card rounded-2xl p-5 lg:p-6">
        <div class="flex flex-col gap-4">
          <div id="drop-zone" class="relative border border-dashed border-slate-600 rounded-xl p-4 lg:p-6 text-center glass cursor-pointer transition hover:border-cyan-400 hover:bg-white/5">
            <input id="file-input" type="file" accept=".mp3,.wav,audio/*" class="absolute inset-0 opacity-0 cursor-pointer">
            <div class="text-sm text-slate-300">Drag & drop audio here or click anywhere</div>
            <div class="text-xs text-slate-500 mt-1">Supports WAV / MP3 · Local only</div>
            <div class="mt-3 flex justify-center">
              <button id="browse-btn" class="px-4 py-2 rounded-lg bg-cyan-500 text-slate-900 font-semibold hover:bg-cyan-400">Browse file</button>
            </div>
          </div>

          <div class="rounded-xl glass p-4 space-y-3">
            <div class="flex items-center justify-between gap-3 text-sm text-slate-200">
              <div class="flex items-center gap-2">
                <button id="play-toggle" class="px-3 py-2 rounded-lg bg-cyan-500 text-slate-900 font-semibold disabled:bg-slate-700 disabled:text-slate-400">Play</button>
                <div id="current-time" class="text-slate-300">0:00</div>
              </div>
              <div class="text-right">
                <div id="file-name" class="text-slate-200 truncate text-xs font-semibold"></div>
                <div id="file-duration" class="text-slate-400 text-[11px]"></div>
              </div>
            </div>
            <div id="waveform" class="h-[140px] rounded-lg overflow-hidden bg-slate-900/60"></div>
            <div class="flex flex-wrap items-center justify-between gap-3 text-sm text-slate-200">
              <div class="flex gap-4">
                <span>In: <span id="in-time" class="text-cyan-300">0:00.000</span></span>
                <span>Out: <span id="out-time" class="text-cyan-300">0:00.000</span></span>
              </div>
              <div class="flex gap-2">
                <button id="add-clip" class="px-3 py-2 rounded-lg bg-white/10 hover:bg-white/20 text-slate-50 font-semibold disabled:bg-slate-800 disabled:text-slate-500">Add Clip</button>
                <button id="play-selection" class="px-3 py-2 rounded-lg bg-white/5 hover:bg-white/15 text-slate-100 font-semibold disabled:bg-slate-800 disabled:text-slate-500">Play Selection</button>
              </div>
            </div>
            <div class="grid sm:grid-cols-2 gap-2 text-xs">
              <label class="flex items-center gap-2 bg-slate-900/60 border border-white/5 rounded-lg px-2 py-2">
                <span class="text-slate-300">Start (s)</span>
                <input id="start-input" type="number" step="0.01" min="0" class="w-full bg-transparent text-slate-100 outline-none" />
              </label>
              <label class="flex items-center gap-2 bg-slate-900/60 border border-white/5 rounded-lg px-2 py-2">
                <span class="text-slate-300">End (s)</span>
                <input id="end-input" type="number" step="0.01" min="0" class="w-full bg-transparent text-slate-100 outline-none" />
              </label>
            </div>
            <div class="flex flex-wrap gap-2 text-xs">
              <button id="select-all" class="px-3 py-2 rounded-lg bg-cyan-500/20 hover:bg-cyan-500/30 text-cyan-100 font-semibold disabled:bg-slate-800 disabled:text-slate-500">Select All</button>
              <button id="clear-selection" class="px-3 py-2 rounded-lg bg-white/10 hover:bg-white/20 text-slate-100 font-semibold disabled:bg-slate-800 disabled:text-slate-500">Clear</button>
              <div id="hint" class="text-slate-400 px-2 py-2">Tip: drag over the waveform to select a region.</div>
            </div>
          </div>
        </div>
      </section>

      <section class="lg:col-span-2 card rounded-2xl p-5 lg:p-6 flex flex-col gap-4">
        <div class="flex items-center justify-between gap-3">
          <div>
            <h2 class="text-xl font-semibold">Clips</h2>
            <div class="text-xs text-slate-400">Min length 0.2s</div>
          </div>
          <div class="flex gap-2">
            <button id="clear-clips" class="px-3 py-2 rounded-lg bg-white/10 hover:bg-white/20 text-slate-100 text-sm font-semibold disabled:bg-slate-800 disabled:text-slate-500">Clear list</button>
          </div>
        </div>
        <div id="clips-empty" class="text-sm text-slate-400">No clips yet. Select a region and press “Add Clip”.</div>
        <div id="clips-list" class="flex flex-col gap-3"></div>
        <div class="border-t border-white/5 pt-4 flex flex-col gap-3">
          <button id="preview-btn" class="w-full px-4 py-3 rounded-xl bg-gradient-to-r from-cyan-400 to-blue-500 text-slate-900 font-semibold disabled:from-slate-700 disabled:to-slate-700 disabled:text-slate-400">Preview Mix</button>
          <button id="export-btn" class="w-full px-4 py-3 rounded-xl bg-white/10 text-slate-100 font-semibold border border-white/5 disabled:bg-slate-800 disabled:text-slate-500">Export WAV</button>
          <div class="text-xs text-slate-400">Fade per clip (0–2s). Clips stitch in list order.</div>
        </div>
      </section>
    </main>
  </div>

  <template id="clip-template">
    <div class="glass rounded-xl p-3 flex flex-col gap-3">
      <div class="flex items-center gap-3">
        <input type="text" class="name-input bg-slate-900/60 border border-white/10 rounded-lg px-3 py-2 w-full text-sm text-slate-100" />
        <div class="flex gap-2">
          <button class="move-up px-2 py-2 rounded-lg bg-white/10 hover:bg-white/20 text-xs">↑</button>
          <button class="move-down px-2 py-2 rounded-lg bg-white/10 hover:bg-white/20 text-xs">↓</button>
        </div>
        <div class="flex gap-2">
          <button class="play-clip px-3 py-2 rounded-lg bg-cyan-500/80 hover:bg-cyan-400 text-slate-900 text-sm font-semibold">Play</button>
          <button class="select-clip px-3 py-2 rounded-lg bg-white/10 hover:bg-white/20 text-slate-100 text-sm font-semibold">Select</button>
          <button class="delete px-3 py-2 rounded-lg bg-rose-500/90 hover:bg-rose-400 text-slate-900 text-sm font-semibold">Delete</button>
        </div>
      </div>
      <div class="flex flex-wrap items-center gap-3 text-xs text-slate-200">
        <div class="px-2 py-1 rounded-lg bg-slate-900/60 border border-white/5">In: <span class="clip-start"></span></div>
        <div class="px-2 py-1 rounded-lg bg-slate-900/60 border border-white/5">Out: <span class="clip-end"></span></div>
        <div class="flex items-center gap-2">
          <label class="text-slate-400">Fade In</label>
          <input type="number" min="0" max="2" step="0.1" class="fade-in bg-slate-900/60 border border-white/10 rounded px-2 py-1 w-20 text-slate-100" />
        </div>
        <div class="flex items-center gap-2">
          <label class="text-slate-400">Fade Out</label>
          <input type="number" min="0" max="2" step="0.1" class="fade-out bg-slate-900/60 border border-white/10 rounded px-2 py-1 w-20 text-slate-100" />
        </div>
        <div class="ml-auto text-slate-400">Duration: <span class="clip-duration text-slate-100"></span></div>
      </div>
    </div>
  </template>

  <script>
    const dropZone = document.getElementById('drop-zone');
    const fileInput = document.getElementById('file-input');
    const fileNameEl = document.getElementById('file-name');
    const fileDurationEl = document.getElementById('file-duration');
    const browseBtn = document.getElementById('browse-btn');
    const playToggle = document.getElementById('play-toggle');
    const currentTimeEl = document.getElementById('current-time');
    const inTimeEl = document.getElementById('in-time');
    const outTimeEl = document.getElementById('out-time');
    const addClipBtn = document.getElementById('add-clip');
    const playSelectionBtn = document.getElementById('play-selection');
    const startInput = document.getElementById('start-input');
    const endInput = document.getElementById('end-input');
    const selectAllBtn = document.getElementById('select-all');
    const clearSelectionBtn = document.getElementById('clear-selection');
    const clearClipsBtn = document.getElementById('clear-clips');
    const clipsList = document.getElementById('clips-list');
    const clipsEmpty = document.getElementById('clips-empty');
    const previewBtn = document.getElementById('preview-btn');
    const exportBtn = document.getElementById('export-btn');
    const clipTemplate = document.getElementById('clip-template');
    const hintEl = document.getElementById('hint');

    let audioCtx;
    let wavesurfer;
    let regionsPlugin;
    let selectionRegion = null;
    let audioBuffer = null;
    let clips = [];
    let previewSource = null;
    let isRendering = false;

    const MIN_CLIP_DURATION = 0.2;

    function initWaveSurfer() {
      wavesurfer = WaveSurfer.create({
        container: '#waveform',
        waveColor: '#38bdf8',
        progressColor: '#818cf8',
        cursorColor: '#e0f2fe',
        height: 140,
        barWidth: 2,
        barGap: 1,
        responsive: true,
        autoScroll: true,
        partialRender: true,
      });

      // Regions plugin lives on WaveSurfer namespace in UMD build
      regionsPlugin = wavesurfer.registerPlugin(WaveSurfer.Regions.create({
        dragSelection: {
          slop: 2,
        },
        color: 'rgba(56, 189, 248, 0.25)',
        resize: true,
        handleStyle: {
          width: '6px',
          backgroundColor: '#38bdf8',
        },
      }));

      regionsPlugin.on('region-created', (region) => {
        if (selectionRegion && selectionRegion.id !== region.id) {
          selectionRegion.remove();
        }
        selectionRegion = region;
        updateSelectionTimes(region.start, region.end);
      });

      regionsPlugin.on('region-updated', (region) => {
        if (region === selectionRegion) {
          updateSelectionTimes(region.start, region.end);
        }
      });

      wavesurfer.on('interaction', () => {
        if (audioCtx && audioCtx.state === 'suspended') {
          audioCtx.resume();
        }
      });

      wavesurfer.on('timeupdate', (time) => {
        currentTimeEl.textContent = formatTime(time);
      });

      wavesurfer.on('play', () => {
        playToggle.textContent = 'Pause';
      });

      wavesurfer.on('pause', () => {
        playToggle.textContent = 'Play';
        playSelectionBtn.textContent = 'Play Selection';
      });

      wavesurfer.on('finish', () => {
        playToggle.textContent = 'Play';
      });

      addClipBtn.disabled = true;
      playToggle.disabled = true;
      previewBtn.disabled = true;
      exportBtn.disabled = true;
      playSelectionBtn.disabled = true;
      startInput.disabled = true;
      endInput.disabled = true;
      selectAllBtn.disabled = true;
      clearSelectionBtn.disabled = true;
      clearClipsBtn.disabled = true;
    }

    function formatTime(time) {
      if (Number.isNaN(time)) return '0:00';
      const minutes = Math.floor(time / 60);
      const seconds = Math.floor(time % 60).toString().padStart(2, '0');
      const millis = Math.floor((time % 1) * 1000).toString().padStart(3, '0');
      return `${minutes}:${seconds}${millis !== '000' ? '.' + millis : ''}`;
    }

    function updateSelectionTimes(start = 0, end = 0) {
      inTimeEl.textContent = formatTime(start);
      outTimeEl.textContent = formatTime(end);
      const tooShort = end - start < MIN_CLIP_DURATION;
      addClipBtn.disabled = !audioBuffer || tooShort;
      playSelectionBtn.disabled = !selectionRegion;
      startInput.disabled = !selectionRegion;
      endInput.disabled = !selectionRegion;
      selectAllBtn.disabled = !audioBuffer;
      clearSelectionBtn.disabled = !selectionRegion;
      playSelectionBtn.textContent = 'Play Selection';
      startInput.value = selectionRegion ? start.toFixed(3) : '';
      endInput.value = selectionRegion ? end.toFixed(3) : '';
      hintEl.textContent = tooShort ? 'Selection is too short (min 0.2s).' : 'Drag, adjust numbers, or use Select All.';
    }

    async function handleFile(file) {
      if (!file) return;
      fileNameEl.textContent = file.name;
      fileDurationEl.textContent = '';
      addClipBtn.disabled = true;
      playToggle.disabled = true;
      clips = [];
      renderClips();
      selectionRegion = null;
      regionsPlugin?.clearRegions();

      const arrayBuffer = await file.arrayBuffer();
      audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
      audioBuffer = await audioCtx.decodeAudioData(arrayBuffer.slice(0));
      wavesurfer.loadBlob(file);
      playToggle.disabled = false;
      clearClipsBtn.disabled = false;
      fileDurationEl.textContent = `Duration: ${formatTime(audioBuffer.duration)}`;
      setSelection(0, audioBuffer.duration);
      previewBtn.disabled = true;
      exportBtn.disabled = true;
    }

    function setSelection(start, end) {
      if (!regionsPlugin || !audioBuffer) return;
      const duration = audioBuffer.duration;
      const clampedStart = Math.max(0, Math.min(start, duration));
      const clampedEnd = Math.max(clampedStart, Math.min(end, duration));
      if (selectionRegion) {
        selectionRegion.remove();
      }
      selectionRegion = regionsPlugin.addRegion({
        start: clampedStart,
        end: clampedEnd,
        color: 'rgba(56, 189, 248, 0.25)',
        resize: true,
        drag: true,
      });
      updateSelectionTimes(clampedStart, clampedEnd);
    }

    function renderClips() {
      clipsList.innerHTML = '';
      if (!clips.length) {
        clipsEmpty.classList.remove('hidden');
        previewBtn.disabled = true;
        exportBtn.disabled = true;
        clearClipsBtn.disabled = true;
        return;
      }
      clipsEmpty.classList.add('hidden');
      previewBtn.disabled = false;
      exportBtn.disabled = false;
      clearClipsBtn.disabled = false;

      clips.forEach((clip, index) => {
        const clone = clipTemplate.content.cloneNode(true);
        const nameInput = clone.querySelector('.name-input');
        const startEl = clone.querySelector('.clip-start');
        const endEl = clone.querySelector('.clip-end');
        const durationEl = clone.querySelector('.clip-duration');
        const fadeInInput = clone.querySelector('.fade-in');
        const fadeOutInput = clone.querySelector('.fade-out');
        const playClipBtn = clone.querySelector('.play-clip');
        const selectClipBtn = clone.querySelector('.select-clip');

        nameInput.value = clip.name;
        startEl.textContent = formatTime(clip.start);
        endEl.textContent = formatTime(clip.end);
        durationEl.textContent = formatTime(clip.end - clip.start);
        fadeInInput.value = clip.fadeIn;
        fadeOutInput.value = clip.fadeOut;

        nameInput.addEventListener('input', (e) => {
          clip.name = e.target.value || `Clip ${index + 1}`;
        });

        fadeInInput.addEventListener('input', (e) => {
          const value = clampFade(e.target.value);
          e.target.value = value;
          clip.fadeIn = value;
        });

        fadeOutInput.addEventListener('input', (e) => {
          const value = clampFade(e.target.value);
          e.target.value = value;
          clip.fadeOut = value;
        });

        clone.querySelector('.move-up').addEventListener('click', () => moveClip(index, -1));
        clone.querySelector('.move-down').addEventListener('click', () => moveClip(index, 1));
        clone.querySelector('.delete').addEventListener('click', () => {
          clips.splice(index, 1);
          renderClips();
        });

        playClipBtn.addEventListener('click', () => playClip(clip));
        selectClipBtn.addEventListener('click', () => setSelection(clip.start, clip.end));

        clipsList.appendChild(clone);
      });
    }

    function clampFade(value) {
      const num = Math.max(0, Math.min(2, parseFloat(value) || 0));
      return Number(num.toFixed(2));
    }

    function moveClip(index, delta) {
      const target = index + delta;
      if (target < 0 || target >= clips.length) return;
      const temp = clips[target];
      clips[target] = clips[index];
      clips[index] = temp;
      renderClips();
    }

    function addClipFromSelection() {
      if (!selectionRegion || !audioBuffer) return;
      const start = selectionRegion.start;
      const end = selectionRegion.end;
      const duration = end - start;
      if (duration < MIN_CLIP_DURATION) return;
      const clip = {
        id: crypto.randomUUID(),
        name: `Clip ${clips.length + 1}`,
        start,
        end,
        fadeIn: 0,
        fadeOut: 0,
      };
      clips.push(clip);
      renderClips();
    }

    function clearSelection() {
      selectionRegion?.remove();
      selectionRegion = null;
      updateSelectionTimes(0, 0);
    }

    async function stitchClips() {
      if (!audioBuffer || !clips.length) return null;
      const sampleRate = audioBuffer.sampleRate;
      const totalDuration = clips.reduce((sum, clip) => sum + (clip.end - clip.start), 0);
      const offlineCtx = new OfflineAudioContext(audioBuffer.numberOfChannels, Math.ceil(totalDuration * sampleRate), sampleRate);

      let offset = 0;
      clips.forEach((clip) => {
        const duration = clip.end - clip.start;
        const source = offlineCtx.createBufferSource();
        source.buffer = audioBuffer;
        const gain = offlineCtx.createGain();

        const startTime = offset;
        const endTime = offset + duration;
        const fadeIn = Math.min(clip.fadeIn, duration);
        const fadeOut = Math.min(clip.fadeOut, duration);

        gain.gain.setValueAtTime(0, startTime);
        if (fadeIn > 0) {
          gain.gain.linearRampToValueAtTime(1, startTime + fadeIn);
        } else {
          gain.gain.setValueAtTime(1, startTime);
        }

        const fadeOutStart = endTime - fadeOut;
        if (fadeOut > 0) {
          gain.gain.setValueAtTime(1, fadeOutStart);
          gain.gain.linearRampToValueAtTime(0, endTime);
        } else {
          gain.gain.setValueAtTime(1, endTime);
        }

        source.connect(gain).connect(offlineCtx.destination);
        source.start(startTime, clip.start, duration);
        offset += duration;
      });

      const rendered = await offlineCtx.startRendering();
      return rendered;
    }

    function audioBufferToWav(buffer) {
      const numChannels = buffer.numberOfChannels;
      const sampleRate = buffer.sampleRate;
      const numFrames = buffer.length;
      const bytesPerSample = 2;
      const blockAlign = numChannels * bytesPerSample;
      const bufferLength = 44 + numFrames * blockAlign;
      const arrayBuffer = new ArrayBuffer(bufferLength);
      const view = new DataView(arrayBuffer);

      function writeString(offset, str) {
        for (let i = 0; i < str.length; i++) {
          view.setUint8(offset + i, str.charCodeAt(i));
        }
      }

      writeString(0, 'RIFF');
      view.setUint32(4, 36 + numFrames * blockAlign, true);
      writeString(8, 'WAVE');
      writeString(12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, numChannels, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * blockAlign, true);
      view.setUint16(32, blockAlign, true);
      view.setUint16(34, bytesPerSample * 8, true);
      writeString(36, 'data');
      view.setUint32(40, numFrames * blockAlign, true);

      let offset = 44;
      const channelData = [];
      for (let i = 0; i < numChannels; i++) {
        channelData.push(buffer.getChannelData(i));
      }

      for (let i = 0; i < numFrames; i++) {
        for (let channel = 0; channel < numChannels; channel++) {
          let sample = channelData[channel][i];
          sample = Math.max(-1, Math.min(1, sample));
          const intSample = sample < 0 ? sample * 0x8000 : sample * 0x7fff;
          view.setInt16(offset, intSample, true);
          offset += 2;
        }
      }
      return new Blob([arrayBuffer], { type: 'audio/wav' });
    }

    async function previewMix() {
      if (isRendering) return;
      if (previewSource) {
        previewSource.stop();
        previewSource.disconnect();
        previewSource = null;
        previewBtn.textContent = 'Preview Mix';
        return;
      }
      isRendering = true;
      previewBtn.textContent = 'Rendering...';
      try {
        const rendered = await stitchClips();
        if (!rendered) return;
        audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
        if (audioCtx.state === 'suspended') await audioCtx.resume();

        previewSource = audioCtx.createBufferSource();
        previewSource.buffer = rendered;
        previewSource.connect(audioCtx.destination);
        previewSource.start();
        previewSource.onended = () => {
          previewBtn.textContent = 'Preview Mix';
          previewSource = null;
        };
        previewBtn.textContent = 'Stop Preview';
      } finally {
        isRendering = false;
      }
    }

    async function exportWav() {
      if (isRendering) return;
      isRendering = true;
      exportBtn.textContent = 'Rendering...';
      exportBtn.disabled = true;
      try {
        const rendered = await stitchClips();
        if (!rendered) return;
        const blob = audioBufferToWav(rendered);
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'edited-audio.wav';
        a.click();
        URL.revokeObjectURL(url);
      } finally {
        isRendering = false;
        exportBtn.textContent = 'Export WAV';
        exportBtn.disabled = clips.length === 0;
      }
    }

    function updateRegionFromInputs() {
      if (!audioBuffer) return;
      const startVal = parseFloat(startInput.value);
      const endVal = parseFloat(endInput.value);
      if (Number.isNaN(startVal) || Number.isNaN(endVal)) return;
      const start = Math.min(startVal, endVal);
      const end = Math.max(startVal, endVal);
      if (end - start < MIN_CLIP_DURATION) {
        hintEl.textContent = 'Selection is too short (min 0.2s).';
        return;
      }
      setSelection(start, end);
    }

    function playSelection() {
      if (!selectionRegion || !wavesurfer) return;
      const { start, end } = selectionRegion;
      if (end - start <= 0) return;
      wavesurfer.play(start, end);
      playSelectionBtn.textContent = 'Playing...';
    }

    function playClip(clip) {
      if (!wavesurfer || !clip) return;
      setSelection(clip.start, clip.end);
      wavesurfer.play(clip.start, clip.end);
    }

    function setupDragAndDrop() {
      const enterClass = 'border-cyan-400 bg-white/5';
      ['dragenter', 'dragover'].forEach((eventName) => {
        dropZone.addEventListener(eventName, (e) => {
          e.preventDefault();
          e.stopPropagation();
          dropZone.classList.add(enterClass);
        });
      });
      ['dragleave', 'drop'].forEach((eventName) => {
        dropZone.addEventListener(eventName, (e) => {
          e.preventDefault();
          e.stopPropagation();
          dropZone.classList.remove(enterClass);
        });
      });
      dropZone.addEventListener('drop', (e) => {
        const file = e.dataTransfer.files?.[0];
        handleFile(file);
      });
      dropZone.addEventListener('click', () => fileInput.click());
      browseBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        fileInput.click();
      });
      fileInput.addEventListener('change', (e) => {
        const file = e.target.files?.[0];
        handleFile(file);
      });
    }

    function setupControls() {
      playToggle.addEventListener('click', () => {
        if (!wavesurfer) return;
        wavesurfer.playPause();
        playToggle.textContent = wavesurfer.isPlaying() ? 'Pause' : 'Play';
      });

      addClipBtn.addEventListener('click', addClipFromSelection);
      playSelectionBtn.addEventListener('click', playSelection);
      startInput.addEventListener('change', updateRegionFromInputs);
      endInput.addEventListener('change', updateRegionFromInputs);
      selectAllBtn.addEventListener('click', () => {
        if (audioBuffer) setSelection(0, audioBuffer.duration);
      });
      clearSelectionBtn.addEventListener('click', clearSelection);
      clearClipsBtn.addEventListener('click', () => {
        clips = [];
        renderClips();
      });
      previewBtn.addEventListener('click', previewMix);
      exportBtn.addEventListener('click', exportWav);
    }

    initWaveSurfer();
    setupDragAndDrop();
    setupControls();
  </script>
</body>
</html>
